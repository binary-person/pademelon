/*
 * ATTENTION: The "eval" devtool has been used (maybe by default in mode: "development").
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
var PademelonWorker;
/******/ (() => { // webpackBootstrap
/******/ 	"use strict";
/******/ 	var __webpack_modules__ = ({

/***/ "./src/base-rewriter-module.ts":
/*!*************************************!*\
  !*** ./src/base-rewriter-module.ts ***!
  \*************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.BasePademelon = void 0;\nconst UrlRewriter_1 = __webpack_require__(/*! ./rewriters/UrlRewriter */ \"./src/rewriters/UrlRewriter.ts\");\nconst css_rewriter_1 = __webpack_require__(/*! ./rewriters/css-rewriter */ \"./src/rewriters/css-rewriter.ts\");\nconst js_rewriter_1 = __webpack_require__(/*! ./rewriters/js-rewriter */ \"./src/rewriters/js-rewriter.ts\");\nconst mod_1 = __webpack_require__(/*! ./mod */ \"./src/mod.ts\");\nconst worker_js_rewriter_1 = __webpack_require__(/*! ./rewriters/worker-js-rewriter */ \"./src/rewriters/worker-js-rewriter.ts\");\nconst defaultBrowserPademelonDistUrl = '/pademelon.min.js';\nconst defaultBrowserImportScriptWorkerUrl = '/pademelon.worker.min.js';\n/**\n * extended by browser and nodejs classes\n */\nclass BasePademelon extends UrlRewriter_1.UrlRewriter {\n    constructor(options) {\n        super(options);\n        this.baseOptions = options;\n        if (!this.baseOptions.windowProp) {\n            this.baseOptions.windowProp = 'pademelonInstance';\n        }\n        if (js_rewriter_1.invalidWindowPropRegex.test(this.baseOptions.windowProp)) {\n            throw new TypeError('Invalid windowProp ' + this.baseOptions.windowProp + '. Does not match regex ' + js_rewriter_1.invalidWindowPropRegex);\n        }\n        if (!this.baseOptions.selfProp) {\n            this.baseOptions.selfProp = 'pademelonInstance';\n        }\n        if (js_rewriter_1.invalidWindowPropRegex.test(this.baseOptions.selfProp)) {\n            throw new TypeError('Invalid selfProp ' + this.baseOptions.windowProp + '. Does not match regex ' + js_rewriter_1.invalidWindowPropRegex);\n        }\n        if (this.baseOptions.windowProp === 'Pademelon') {\n            throw new TypeError('windowProp cannot be the same name as the class name');\n        }\n    }\n    /**\n     * @param cssText - raw css text\n     * @param proxyPath - original proxy path\n     * @example ```typescript\n     * const cssText = '@import \"/someother.css\"; body{background-color: url(asset.png)}';\n     * const rewrittenCSSText = pademelon.rewriteCSS(cssText, '/proxyprefix/https://example.com');\n     * // rewrittenCSSText:\n     * '@import \"https://proxysite.com/proxy/cs_/https://example.com/someother.css\"; body{background-color: url(https://proxysite.com/proxy/st_/https://example.com/asset.png)}'\n     * ```\n     */\n    rewriteCSS(cssText, proxyPath) {\n        return css_rewriter_1.cssRewriter(cssText, (unrewrittenUrl, cssUrlType) => {\n            let mod;\n            if (!this.baseOptions.noMod) {\n                if (cssUrlType === '@import') {\n                    mod = mod_1.typeToMod('stylesheet');\n                }\n                else {\n                    mod = mod_1.typeToMod('raw');\n                }\n            }\n            return this.rewriteUrl(unrewrittenUrl, proxyPath, mod);\n        });\n    }\n    rewriteJS(jsCode) {\n        return js_rewriter_1.jsRewriter(jsCode, this.baseOptions.windowProp);\n    }\n    rewriteWorkerJS(workerJsCode) {\n        return worker_js_rewriter_1.workerJsRewriter(workerJsCode, this.getBrowserImportScriptWorkerUrl(), JSON.stringify(this.baseOptions), this.baseOptions.selfProp);\n    }\n    generateDefaultPademelonInitCode() {\n        return ('window.' +\n            this.baseOptions.windowProp +\n            ' = new Pademelon(' +\n            JSON.stringify(this.baseOptions) +\n            ');' +\n            this.baseOptions.windowProp +\n            '.init()');\n    }\n    getBrowserPademelonDistUrl() {\n        return this.baseOptions.browserPademelonDistUrl || defaultBrowserPademelonDistUrl;\n    }\n    getBrowserImportScriptWorkerUrl() {\n        return this.baseOptions.browserImportScriptWorkerUrl || defaultBrowserImportScriptWorkerUrl;\n    }\n    generateDefaultPademelonInject() {\n        const pademelonDist = '<script src=\"' + this.getBrowserPademelonDistUrl() + '\"></script>';\n        const pademelonInit = '<script>' + this.generateDefaultPademelonInitCode() + '</script>';\n        return pademelonDist + pademelonInit;\n    }\n}\nexports.BasePademelon = BasePademelon;\n\n\n//# sourceURL=webpack://PademelonWorker/./src/base-rewriter-module.ts?");

/***/ }),

/***/ "./src/browser-rewrites/fakeToString.ts":
/*!**********************************************!*\
  !*** ./src/browser-rewrites/fakeToString.ts ***!
  \**********************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.fakeToString = void 0;\nconst nativeFunctionPrefix = 'function ';\nconst nativeFunctionSuffix = '() { [native code] }';\nconst toStringFunc = () => {\n    return nativeFunctionPrefix + 'toString' + nativeFunctionSuffix;\n};\ntoStringFunc.toString = toStringFunc;\ntoStringFunc.toString.toString = toStringFunc.toString;\nfunction fakeToString(func, funcName = '') {\n    func.toString = () => {\n        return nativeFunctionPrefix + funcName + nativeFunctionSuffix;\n    };\n    func.toString.toString = toStringFunc;\n    return func;\n}\nexports.fakeToString = fakeToString;\nconst funcProto = Function.prototype;\nconst originalToString = funcProto.toString;\nfuncProto.toString = function () {\n    if (this.toString === toStringFunc) {\n        return this.toString();\n    }\n    else if (this.toString.toString === toStringFunc && this.toString !== funcProto.toString) {\n        return this.toString();\n    }\n    else {\n        return originalToString.call(this);\n    }\n};\nfuncProto.toString.toString = toStringFunc;\n\n\n//# sourceURL=webpack://PademelonWorker/./src/browser-rewrites/fakeToString.ts?");

/***/ }),

/***/ "./src/browser-rewrites/interceptObject.ts":
/*!*************************************************!*\
  !*** ./src/browser-rewrites/interceptObject.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\n/**\n * used to rewrite properties that are configurable: false.\n * This is intended to be a wrapper for Proxy because it\n * doesn't allow one to return a changed property for configurable: false\n * properties\n */\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.interceptObject = void 0;\nconst primitives = [Boolean, Number, String, BigInt, Symbol, Object];\n// Proxy: do not bind because it doesn't need to and the simple constructor check by checking\n// the existence of a prototype property fails only with Proxy\nconst otherDoNotBindFuncs = [Proxy];\n// store a reference to toString because rewriteWindowFunction will overwrite Function, resulting\n// in an infinite loop of referencing its own prototype property\nconst funcToString = Function.prototype.toString;\nfunction doNotBindFunction(func) {\n    // needed in order to pass test262 unit tests\n    if (func === Error || func instanceof Error || func.prototype instanceof Error)\n        return true;\n    // primitives don't care if they aren't binded to the window object, and also,\n    // avoid binding them to pass test262 unit tests\n    if (primitives.includes(func))\n        return true;\n    if (otherDoNotBindFuncs.includes(func))\n        return true;\n    // avoid binding because we need it to bind to the proxy object, not the real object,\n    // as when the obj.func.call(obj) gets run, func's proxy apply trap can properly handle it\n    // (which won't if we don't bind)\n    // also, avoid caching a reference to otherDoNotBindFuncs because Function.prototype.call will\n    // get modified and we want to grab the latest copy\n    if (Function.prototype.call === func || Function.prototype.bind === func || Function.prototype.apply === func)\n        return true;\n    // the only reason we want to bind functions is some native functions on the window object\n    // don't like it when they are called with the 'this' not binded to a window.\n    // if we were to extend the binding to other functions created by the page's js,\n    // we will create all sorts of problems\n    if (!/\\{\\s+\\[native code\\]/.test(funcToString.call(func)))\n        return true;\n    return false;\n}\nfunction hasProperty(obj, prop) {\n    return Object.prototype.hasOwnProperty.call(obj, prop);\n}\nfunction isEmptyObj(obj) {\n    return Object.keys(Object.getOwnPropertyDescriptors(obj)).length === 0;\n}\nfunction interceptObject(targetObject, { modifiedProperties = {}, parentObject, parentProxyObject, getHook = () => undefined, rewriteArgs, rewriteReturn, rewriteThis, useOriginalTarget = isEmptyObj(modifiedProperties) } = {}) {\n    if (useOriginalTarget && !isEmptyObj(modifiedProperties)) {\n        throw new TypeError('Cannot use original target and have a non-empty modifiedProperties');\n    }\n    const bindCache = Object.create(null);\n    /* eslint-disable @typescript-eslint/no-empty-function */\n    const carbonCopy = typeof targetObject === 'function' ? (hasProperty(targetObject, 'prototype') ? function () { } : () => { }) : {};\n    Object.setPrototypeOf(carbonCopy, targetObject);\n    /* eslint-enable @typescript-eslint/no-empty-function */\n    const proxyObject = new Proxy(useOriginalTarget ? targetObject : carbonCopy, {\n        getPrototypeOf: () => Reflect.getPrototypeOf(targetObject),\n        setPrototypeOf: (_target, prop) => Reflect.setPrototypeOf(targetObject, prop),\n        isExtensible: () => Reflect.isExtensible(targetObject),\n        preventExtensions: () => Reflect.preventExtensions(targetObject),\n        defineProperty: (_target, prop, descriptor) => Reflect.defineProperty(targetObject, prop, descriptor),\n        ownKeys: () => Reflect.ownKeys(targetObject),\n        has: (_target, prop) => {\n            getHook(prop);\n            Reflect.getOwnPropertyDescriptor(proxyObject, prop);\n            return Reflect.has(targetObject, prop);\n        },\n        construct: (_target, argArray, newTarget) => {\n            const returnValue = Reflect.construct(targetObject, rewriteArgs ? rewriteArgs.call(undefined, argArray, true) : argArray, newTarget);\n            if (rewriteReturn)\n                return rewriteReturn.call(undefined, returnValue, argArray, true);\n            return returnValue;\n        },\n        apply: (_target, thisArg, argArray) => {\n            thisArg =\n                parentObject && (!(thisArg || parentProxyObject) || thisArg === parentProxyObject)\n                    ? parentObject\n                    : thisArg;\n            thisArg = rewriteThis ? rewriteThis(thisArg) : thisArg;\n            const returnValue = Reflect.apply(targetObject, thisArg, rewriteArgs ? rewriteArgs.call(thisArg, argArray, false) : argArray);\n            if (rewriteReturn)\n                return rewriteReturn.call(thisArg, returnValue, argArray, false);\n            return returnValue;\n        },\n        deleteProperty: (_target, prop) => {\n            if (hasProperty(bindCache, prop)) {\n                delete bindCache[prop];\n            }\n            if (hasProperty(carbonCopy, prop)) {\n                Reflect.deleteProperty(carbonCopy, prop);\n            }\n            return Reflect.deleteProperty(targetObject, prop);\n        },\n        getOwnPropertyDescriptor(_target, prop) {\n            if (useOriginalTarget)\n                return Reflect.getOwnPropertyDescriptor(targetObject, prop);\n            let desc;\n            if (hasProperty(modifiedProperties, prop)) {\n                desc = Reflect.getOwnPropertyDescriptor(modifiedProperties, prop);\n            }\n            else {\n                desc = Reflect.getOwnPropertyDescriptor(targetObject, prop);\n            }\n            if (!desc) {\n                return;\n            }\n            Reflect.defineProperty(carbonCopy, prop, desc);\n            return Reflect.getOwnPropertyDescriptor(carbonCopy, prop);\n        },\n        get(_target, prop, receiver) {\n            if (useOriginalTarget)\n                return Reflect.get(targetObject, prop, receiver);\n            getHook(prop);\n            receiver = receiver === proxyObject ? targetObject : receiver;\n            if (hasProperty(modifiedProperties, prop)) {\n                return Reflect.get(modifiedProperties, prop, receiver);\n            }\n            else {\n                let value = Reflect.get(targetObject, prop, receiver);\n                if (typeof value === 'function' && !doNotBindFunction(value)) {\n                    if (!(prop in bindCache) || bindCache[prop].originalFunc !== value) {\n                        bindCache[prop] = {\n                            originalFunc: value,\n                            bindedFunc: interceptObject(value, {\n                                parentObject: rewriteArgs || rewriteReturn ? proxyObject : targetObject,\n                                parentProxyObject: proxyObject,\n                                useOriginalTarget: false\n                            })\n                        };\n                    }\n                    value = bindCache[prop].bindedFunc;\n                }\n                else if (prop in bindCache) {\n                    delete bindCache[prop];\n                }\n                const originalDesc = Reflect.getOwnPropertyDescriptor(targetObject, prop);\n                if (originalDesc && !originalDesc.configurable && originalDesc.writable) {\n                    Reflect.set(carbonCopy, prop, value);\n                }\n                return value;\n            }\n        },\n        set(_target, prop, value, receiver) {\n            if (useOriginalTarget)\n                Reflect.set(targetObject, prop, value, receiver);\n            receiver = receiver === proxyObject ? targetObject : receiver;\n            if (hasProperty(modifiedProperties, prop)) {\n                return Reflect.set(modifiedProperties, prop, value);\n            }\n            return Reflect.set(targetObject, prop, value);\n        }\n    });\n    // force cache all of non-configurable objects and add them to carbonCopy\n    const descs = Object.assign(Object.getOwnPropertyDescriptors(targetObject), Object.getOwnPropertyDescriptors(modifiedProperties));\n    for (const eachProp in descs) {\n        if (descs[eachProp] && !descs[eachProp].configurable && descs[eachProp].value) {\n            const value = Reflect.get(proxyObject, eachProp);\n            descs[eachProp].value = value;\n            Reflect.defineProperty(carbonCopy, eachProp, descs[eachProp]);\n        }\n    }\n    return proxyObject;\n}\nexports.interceptObject = interceptObject;\n\n\n//# sourceURL=webpack://PademelonWorker/./src/browser-rewrites/interceptObject.ts?");

/***/ }),

/***/ "./src/browser-rewrites/rewriteFunction.ts":
/*!*************************************************!*\
  !*** ./src/browser-rewrites/rewriteFunction.ts ***!
  \*************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.rewriteFunction = void 0;\nconst interceptObject_1 = __webpack_require__(/*! ./interceptObject */ \"./src/browser-rewrites/interceptObject.ts\");\n// primarily handles type issues\nfunction toBindOrNotToBind(isConstructor, func, thisArg) {\n    if (!isConstructor && typeof func === 'function') {\n        return func.bind(thisArg);\n    }\n    return func;\n}\n/**\n *\n * @param obj - property's object to rewrite\n * @param prop - property to rewrite\n * @param interceptArgs - interceptArgs gets executed and its array return value will be used to replace\n * the args that will be passed on to the original function.\n * @param interceptReturn - after the function call, its return value will be passed to interceptReturn\n * to rewrite the return value along with original args. this parameter is optional\n * @param interceptThis - before function call. the return value of interceptThis will be used\n * to bind the 'this' when calling the original function\n * @param hookAfterCall - gets called after everything but before the actual return (quite frankly\n * impossible to do unless one uses setTimeout)\n */\nfunction rewriteFunction(func, { interceptArgs, interceptReturn, interceptThis, hookAfterCall }) {\n    if (typeof func !== 'function') {\n        throw new TypeError(func + ' is not a function');\n    }\n    if (!interceptArgs && !interceptReturn && !interceptThis && !hookAfterCall) {\n        throw new TypeError('At least one of the functions must be defined');\n    }\n    const originalFunc = func;\n    return interceptObject_1.interceptObject(originalFunc, {\n        rewriteArgs(args, isConstructor) {\n            return interceptArgs\n                ? interceptArgs.call(this, toBindOrNotToBind(isConstructor, originalFunc, this), ...args)\n                : args;\n        },\n        rewriteReturn(returnValue, args, isConstructor) {\n            if (interceptReturn)\n                returnValue = interceptReturn.call(this, toBindOrNotToBind(isConstructor, originalFunc, this), returnValue, ...args);\n            if (hookAfterCall)\n                hookAfterCall(toBindOrNotToBind(isConstructor, originalFunc, this), returnValue, ...args);\n            return returnValue;\n        },\n        rewriteThis(thisArg) {\n            if (interceptThis)\n                thisArg = interceptThis(originalFunc, thisArg);\n            return thisArg;\n        }\n    });\n}\nexports.rewriteFunction = rewriteFunction;\n\n\n//# sourceURL=webpack://PademelonWorker/./src/browser-rewrites/rewriteFunction.ts?");

/***/ }),

/***/ "./src/browser-rewrites/rewriteGetterSetter.ts":
/*!*****************************************************!*\
  !*** ./src/browser-rewrites/rewriteGetterSetter.ts ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.rewriteGetterSetter = void 0;\nconst fakeToString_1 = __webpack_require__(/*! ./fakeToString */ \"./src/browser-rewrites/fakeToString.ts\");\n/**\n *\n * @param obj - property's object to rewrite\n * @param prop - property to rewrite\n * @param rewriteGetter - original getter function will be called first, then its return value\n * will be intercepted by rewriteGetter and rewriteGetter's return value will be passed onto the\n * caller. If originalGetter doesn't exist, nothing will happen. If !rewriteGetter, the original\n * getter will be used instead\n * @param rewriteSetter - rewriteSetter will be called with setValue passed as a param. rewriteSetter's\n * return value will be passed onto the original setter. If originalSetter doesn't exist, nothing will\n * happen. If !rewriteSetter, the original setter will be used instead\n * @param hookAfterGetter - executed after call to original getter\n * @param hookAfterSetter - executed after call to original setter\n * @param preventCallToGetter\n * @param preventCallToSetter\n */\nfunction rewriteGetterSetter(obj, prop, { rewriteGetter, rewriteSetter, hookAfterGetter, hookAfterSetter, preventCallToGetter, preventCallToSetter }) {\n    if (!rewriteGetter &&\n        !rewriteSetter &&\n        !hookAfterGetter &&\n        !hookAfterSetter &&\n        preventCallToGetter === undefined &&\n        preventCallToSetter === undefined) {\n        throw new TypeError('At least one of rewrites or hooks or flags must be set');\n    }\n    const propDescriptor = Object.getOwnPropertyDescriptor(obj, prop);\n    if (!propDescriptor) {\n        throw new TypeError('prop descriptor not defined. Is this a valid object?');\n    }\n    if (!propDescriptor.configurable) {\n        throw new TypeError('target prop not configurable');\n    }\n    if (!propDescriptor.get && !propDescriptor.set) {\n        throw new TypeError('target prop does not have a getter nor a setter');\n    }\n    if (propDescriptor.get && (rewriteGetter || hookAfterGetter)) {\n        const originalGetter = propDescriptor.get;\n        propDescriptor.get = function () {\n            const originalReturnValue = originalGetter.call(this);\n            const modifiedReturnValue = rewriteGetter\n                ? preventCallToGetter\n                    ? undefined\n                    : rewriteGetter.call(this, originalReturnValue)\n                : originalReturnValue;\n            if (hookAfterGetter)\n                hookAfterGetter.call(this, originalReturnValue, modifiedReturnValue);\n            return modifiedReturnValue;\n        };\n        fakeToString_1.fakeToString(propDescriptor.get, prop.toString());\n    }\n    if (propDescriptor.set && (rewriteSetter || hookAfterSetter)) {\n        const originalSetter = propDescriptor.set;\n        propDescriptor.set = function (value) {\n            const modifiedValue = rewriteSetter ? rewriteSetter.call(this, value) : value;\n            if (!preventCallToSetter)\n                originalSetter.call(this, modifiedValue);\n            if (hookAfterSetter)\n                hookAfterSetter.call(this, value, modifiedValue);\n        };\n        fakeToString_1.fakeToString(propDescriptor.set, prop.toString());\n    }\n    Object.defineProperty(obj, prop, propDescriptor);\n}\nexports.rewriteGetterSetter = rewriteGetterSetter;\n\n\n//# sourceURL=webpack://PademelonWorker/./src/browser-rewrites/rewriteGetterSetter.ts?");

/***/ }),

/***/ "./src/browser-rewrites/worker-rewrites/self/Request.ts":
/*!**************************************************************!*\
  !*** ./src/browser-rewrites/worker-rewrites/self/Request.ts ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.rewriteWorkerRequest = void 0;\nconst mod_1 = __webpack_require__(/*! ../../../mod */ \"./src/mod.ts\");\nconst rewriteFunction_1 = __webpack_require__(/*! ../../rewriteFunction */ \"./src/browser-rewrites/rewriteFunction.ts\");\nfunction rewriteWorkerRequest(pademelonInstance) {\n    self.Request = rewriteFunction_1.rewriteFunction(self.Request, {\n        // reminder that this is a constructor so it returns an instance of Request\n        interceptArgs(_Request, input, initOpts) {\n            let url;\n            if (typeof input === 'string') {\n                url = input;\n            }\n            else if ('url' in input) {\n                url = input.url;\n            }\n            else {\n                url = input;\n            }\n            return [\n                new _Request(pademelonInstance.rewriteUrl(url, undefined, mod_1.typeToMod('api')), new _Request(input, initOpts))\n            ];\n        }\n    });\n}\nexports.rewriteWorkerRequest = rewriteWorkerRequest;\n\n\n//# sourceURL=webpack://PademelonWorker/./src/browser-rewrites/worker-rewrites/self/Request.ts?");

/***/ }),

/***/ "./src/browser-rewrites/worker-rewrites/self/Response.prototype.ts":
/*!*************************************************************************!*\
  !*** ./src/browser-rewrites/worker-rewrites/self/Response.prototype.ts ***!
  \*************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.rewriteWorkerResponse = void 0;\nconst rewriteGetterSetter_1 = __webpack_require__(/*! ../../rewriteGetterSetter */ \"./src/browser-rewrites/rewriteGetterSetter.ts\");\nfunction rewriteWorkerResponse(pademelonInstance) {\n    rewriteGetterSetter_1.rewriteGetterSetter(self.Response.prototype, 'url', {\n        rewriteGetter: (returnValue) => {\n            if (returnValue) {\n                returnValue = pademelonInstance.unrewriteUrl(returnValue).url;\n            }\n            return returnValue;\n        }\n    });\n}\nexports.rewriteWorkerResponse = rewriteWorkerResponse;\n\n\n//# sourceURL=webpack://PademelonWorker/./src/browser-rewrites/worker-rewrites/self/Response.prototype.ts?");

/***/ }),

/***/ "./src/browser-rewrites/worker-rewrites/self/WorkerGlobalScope.prototype/fetch.ts":
/*!****************************************************************************************!*\
  !*** ./src/browser-rewrites/worker-rewrites/self/WorkerGlobalScope.prototype/fetch.ts ***!
  \****************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.rewriteWorkerfetch = void 0;\nconst rewriteFunction_1 = __webpack_require__(/*! ../../../rewriteFunction */ \"./src/browser-rewrites/rewriteFunction.ts\");\n/**\n * this wraps the request url by sending it through the already wrapped Request\n * then unrewrites the response url after the request\n */\nfunction rewriteWorkerfetch(pademelonInstance) {\n    self.fetch = rewriteFunction_1.rewriteFunction(self.fetch, {\n        interceptArgs(_, input, initOpts) {\n            return [new Request(input, initOpts)];\n        },\n        interceptReturn(_, returnPromiseResponse) {\n            return new Promise((resolve, reject) => {\n                returnPromiseResponse\n                    .then((response) => {\n                    Object.defineProperty(response, 'url', {\n                        value: pademelonInstance.unrewriteUrl(response.url).url\n                    });\n                    resolve(response);\n                })\n                    .catch(reject);\n            });\n        }\n    });\n}\nexports.rewriteWorkerfetch = rewriteWorkerfetch;\n\n\n//# sourceURL=webpack://PademelonWorker/./src/browser-rewrites/worker-rewrites/self/WorkerGlobalScope.prototype/fetch.ts?");

/***/ }),

/***/ "./src/browser-rewrites/worker-rewrites/self/WorkerGlobalScope.prototype/importScripts.ts":
/*!************************************************************************************************!*\
  !*** ./src/browser-rewrites/worker-rewrites/self/WorkerGlobalScope.prototype/importScripts.ts ***!
  \************************************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.rewriteWorkerimportScripts = void 0;\nconst mod_1 = __webpack_require__(/*! ../../../../mod */ \"./src/mod.ts\");\nconst rewriteFunction_1 = __webpack_require__(/*! ../../../rewriteFunction */ \"./src/browser-rewrites/rewriteFunction.ts\");\nfunction rewriteWorkerimportScripts(pademelonInstance) {\n    self.importScripts = rewriteFunction_1.rewriteFunction(self.importScripts, {\n        interceptArgs(_, ...scriptUrls) {\n            for (let i = 0; i < scriptUrls.length; i++) {\n                scriptUrls[i] = pademelonInstance.rewriteUrl(scriptUrls[i] + '', undefined, mod_1.typeToMod('webworker')); // toString without having typescript throw an error\n            }\n            return scriptUrls;\n        }\n    });\n}\nexports.rewriteWorkerimportScripts = rewriteWorkerimportScripts;\n\n\n//# sourceURL=webpack://PademelonWorker/./src/browser-rewrites/worker-rewrites/self/WorkerGlobalScope.prototype/importScripts.ts?");

/***/ }),

/***/ "./src/browser-rewrites/worker-rewrites/self/WorkerLocation.prototype.ts":
/*!*******************************************************************************!*\
  !*** ./src/browser-rewrites/worker-rewrites/self/WorkerLocation.prototype.ts ***!
  \*******************************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.rewriteWorkerWorkerLocationProto = void 0;\nconst rewriteFunction_1 = __webpack_require__(/*! ../../rewriteFunction */ \"./src/browser-rewrites/rewriteFunction.ts\");\nconst rewriteGetterSetter_1 = __webpack_require__(/*! ../../rewriteGetterSetter */ \"./src/browser-rewrites/rewriteGetterSetter.ts\");\nfunction rewriteWorkerWorkerLocationProto(pademelonInstance) {\n    const rewrittenLocation = new URL(pademelonInstance.unrewriteUrl().url);\n    const propertiesToRewrite = ['hash', 'host', 'hostname', 'href', 'origin', 'pathname', 'port', 'protocol', 'search'];\n    for (const eachProperty of propertiesToRewrite) {\n        rewriteGetterSetter_1.rewriteGetterSetter(self.WorkerLocation.prototype, eachProperty, {\n            rewriteGetter() {\n                return rewrittenLocation[eachProperty];\n            }\n        });\n    }\n    self.WorkerLocation.prototype.toString = rewriteFunction_1.rewriteFunction(self.WorkerLocation.prototype.toString, {\n        interceptReturn() {\n            return rewrittenLocation.href;\n        }\n    });\n}\nexports.rewriteWorkerWorkerLocationProto = rewriteWorkerWorkerLocationProto;\n\n\n//# sourceURL=webpack://PademelonWorker/./src/browser-rewrites/worker-rewrites/self/WorkerLocation.prototype.ts?");

/***/ }),

/***/ "./src/browser-rewrites/worker-rewrites/self/index.ts":
/*!************************************************************!*\
  !*** ./src/browser-rewrites/worker-rewrites/self/index.ts ***!
  \************************************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.workerRewriters = void 0;\nconst Request_1 = __webpack_require__(/*! ./Request */ \"./src/browser-rewrites/worker-rewrites/self/Request.ts\");\nconst Response_prototype_1 = __webpack_require__(/*! ./Response.prototype */ \"./src/browser-rewrites/worker-rewrites/self/Response.prototype.ts\");\nconst fetch_1 = __webpack_require__(/*! ./WorkerGlobalScope.prototype/fetch */ \"./src/browser-rewrites/worker-rewrites/self/WorkerGlobalScope.prototype/fetch.ts\");\nconst importScripts_1 = __webpack_require__(/*! ./WorkerGlobalScope.prototype/importScripts */ \"./src/browser-rewrites/worker-rewrites/self/WorkerGlobalScope.prototype/importScripts.ts\");\nconst WorkerLocation_prototype_1 = __webpack_require__(/*! ./WorkerLocation.prototype */ \"./src/browser-rewrites/worker-rewrites/self/WorkerLocation.prototype.ts\");\nconst workerRewriters = [\n    // native api network requests\n    fetch_1.rewriteWorkerfetch,\n    Request_1.rewriteWorkerRequest,\n    Response_prototype_1.rewriteWorkerResponse,\n    // other native apis that utilize networking\n    importScripts_1.rewriteWorkerimportScripts,\n    // navigation\n    WorkerLocation_prototype_1.rewriteWorkerWorkerLocationProto\n];\nexports.workerRewriters = workerRewriters;\n\n\n//# sourceURL=webpack://PademelonWorker/./src/browser-rewrites/worker-rewrites/self/index.ts?");

/***/ }),

/***/ "./src/mod.ts":
/*!********************!*\
  !*** ./src/mod.ts ***!
  \********************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.modToType = exports.typeToMod = void 0;\nconst UrlRewriter_1 = __webpack_require__(/*! ./rewriters/UrlRewriter */ \"./src/rewriters/UrlRewriter.ts\");\nconst TYPE_TO_MOD = {\n    html: '',\n    javascript: 'js_',\n    stylesheet: 'cs_',\n    webworker: 'ww_',\n    serviceworker: 'sw_',\n    raw: 'rw_',\n    api: 'ap_'\n};\nObject.keys(TYPE_TO_MOD).forEach((eachMod) => {\n    const typedMod = eachMod; // get typescript to shush about incompatibility of eachMod: string and modTypes\n    if (!UrlRewriter_1.allowedModRegex.test(TYPE_TO_MOD[typedMod])) {\n        throw new TypeError('Invalid mod in mod.ts file. Please file an issue and include ' +\n            'the following information: TYPE_TO_MOD[' +\n            eachMod +\n            '] = ' +\n            TYPE_TO_MOD[typedMod] +\n            ' violates the regex ' +\n            UrlRewriter_1.allowedModRegex);\n    }\n});\nfunction typeToMod(type) {\n    if (type && type in TYPE_TO_MOD) {\n        return TYPE_TO_MOD[type];\n    }\n    return '';\n}\nexports.typeToMod = typeToMod;\nfunction modToType(mod) {\n    for (const eachType in TYPE_TO_MOD) {\n        if (TYPE_TO_MOD[eachType] === mod) {\n            return eachType;\n        }\n    }\n    return 'raw';\n}\nexports.modToType = modToType;\n\n\n//# sourceURL=webpack://PademelonWorker/./src/mod.ts?");

/***/ }),

/***/ "./src/rewriters/UrlRewriter.ts":
/*!**************************************!*\
  !*** ./src/rewriters/UrlRewriter.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.allowedModRegex = exports.UrlRewriter = void 0;\nconst urlSchemes = ['http://', 'https://', 'ws://', 'wss://', '//'];\nconst allowedModRegex = /^\\d*[a-z]+_$|^$/;\nexports.allowedModRegex = allowedModRegex;\nconst websocketUrlRegex = /^wss?:\\/\\//i;\nconst httpUrlRegex = /^http(s)?:\\/\\//i;\nconst nonRelativeRegex = /^\\/\\/|^(http|ws)s?:\\/\\//i;\nconst defaultPrefixBlacklist = ['data:', 'blob:', 'about:', 'ftp:', 'file:', 'javascript:'];\nconst defaultUrlBlacklist = ['about:blank'];\nfunction appendEachUrlScheme(suffix) {\n    const arr = [];\n    for (const eachScheme of urlSchemes) {\n        arr.push(eachScheme + suffix);\n    }\n    return arr;\n}\nclass UrlRewriter {\n    constructor(options) {\n        if (!options.pathnamePrefix.startsWith('/')) {\n            throw new TypeError('Expected pathnamePrefix to start with /');\n        }\n        if (!options.pathnamePrefix.endsWith('/')) {\n            throw new TypeError('Expected pathnamePrefix to end with /');\n        }\n        if (options.hostname.endsWith('/')) {\n            throw new TypeError('Unexpected trailing slash in hostname');\n        }\n        this.proxyPrefix = options.hostname + options.pathnamePrefix;\n        if (options.useHttp) {\n            this.proxyPrefix = 'http://' + this.proxyPrefix;\n        }\n        else {\n            this.proxyPrefix = 'https://' + this.proxyPrefix;\n        }\n        if (!options.blacklistPrefixes) {\n            options.blacklistPrefixes = [];\n        }\n        options.blacklistPrefixes = options.blacklistPrefixes.concat(defaultPrefixBlacklist);\n        if (!options.blacklistUrls) {\n            options.blacklistUrls = [];\n        }\n        options.blacklistUrls = options.blacklistUrls.concat(defaultUrlBlacklist);\n        this.proxyPrefixes = [];\n        // scheme://hostname/pathnamePrefix/\n        this.proxyPrefixes.push(...appendEachUrlScheme(options.hostname + options.pathnamePrefix));\n        // /pathnamePrefix/\n        this.proxyPrefixes.push(options.pathnamePrefix);\n        this.urlRewriterOptions = options;\n    }\n    getProxyPrefix(url) {\n        for (const proxyPrefix of this.proxyPrefixes) {\n            if (url.startsWith(proxyPrefix)) {\n                return proxyPrefix;\n            }\n        }\n        return false;\n    }\n    isBlacklistedPrefix(url) {\n        for (const blacklistPrefix of this.urlRewriterOptions.blacklistPrefixes) {\n            if (url.startsWith(blacklistPrefix)) {\n                return true;\n            }\n        }\n        return false;\n    }\n    unrewriteUrl(proxyUrl = '') {\n        if (typeof this.urlRewriterOptions.unrewriteUrlIntercept === 'function') {\n            proxyUrl = this.urlRewriterOptions.unrewriteUrlIntercept(proxyUrl);\n        }\n        const proxyPrefix = this.getProxyPrefix(proxyUrl);\n        if (proxyPrefix === false) {\n            return { url: proxyUrl, fail: true };\n        }\n        // destUrl without mod: https://example.com\n        // destUrl with mod: somemod_/https://example.com\n        let destUrl = proxyUrl.slice(proxyPrefix.length);\n        let mod;\n        const nextSlash = destUrl.indexOf('/');\n        if (nextSlash !== -1) {\n            // url possibly contains a mod\n            const testmod = destUrl.slice(0, nextSlash);\n            if (allowedModRegex.test(testmod)) {\n                mod = testmod;\n                destUrl = destUrl.slice(nextSlash + 1);\n            }\n        }\n        return { url: destUrl, mod };\n    }\n    rewriteUrl(url, proxyPath = '', mod) {\n        var _a;\n        url = url.toString();\n        if (this.isBlacklistedPrefix(url) ||\n            this.getProxyPrefix(url) !== false || ((_a = this.urlRewriterOptions.blacklistUrls) === null || _a === void 0 ? void 0 : _a.includes(url))) {\n            return url;\n        }\n        let prefix;\n        if (nonRelativeRegex.test(url)) {\n            prefix = this.proxyPrefix;\n        }\n        else {\n            prefix = this.urlRewriterOptions.pathnamePrefix;\n        }\n        let currentDestUrl;\n        try {\n            const unrewrittenUrl = this.unrewriteUrl(proxyPath);\n            if (unrewrittenUrl.fail) {\n                return url;\n            }\n            else {\n                currentDestUrl = new URL(url, unrewrittenUrl.url);\n            }\n        }\n        catch (e) {\n            return url;\n        }\n        if (mod) {\n            if (allowedModRegex.test(mod)) {\n                prefix += mod + '/';\n            }\n            else {\n                throw new TypeError(mod + ' mod not allowed. Does not match the regex ' + allowedModRegex);\n            }\n        }\n        // rewrite proxy prefix with wss urls appropriately\n        if (websocketUrlRegex.test(currentDestUrl.href)) {\n            prefix = prefix.replace(httpUrlRegex, 'ws$1://');\n        }\n        let rewrittenUrl = prefix + currentDestUrl.href;\n        if (typeof this.urlRewriterOptions.rewriteUrlIntercept === 'function') {\n            rewrittenUrl = this.urlRewriterOptions.rewriteUrlIntercept(rewrittenUrl);\n        }\n        return rewrittenUrl;\n    }\n}\nexports.UrlRewriter = UrlRewriter;\n\n\n//# sourceURL=webpack://PademelonWorker/./src/rewriters/UrlRewriter.ts?");

/***/ }),

/***/ "./src/rewriters/css-rewriter.ts":
/*!***************************************!*\
  !*** ./src/rewriters/css-rewriter.ts ***!
  \***************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.unescapeString = exports.escapeString = exports.cssRewriter = void 0;\n// quote regex modified from\n// https://stackoverflow.com/questions/171480/regex-grabbing-values-between-quotation-marks#comment87998981_171499\n// :~ means capture group is used to recreate the original string, and not used in processing\n// capture group 1: @import, url\n// capture group 2:~ *space between (@import or url) and (quote or the actual url)\n// capture group 3: \" for url(\"aa\"), ', or nothing for url(aa); used to unescape strings from \"aa\\'aa\" to \"aa'aa\"`\n// capture group 4: the actual url\n// matches @import \"a\", @import ' \\'a'\nconst importRegex = /(@import)(\\s*)([\"'])((?:\\\\.|[^\\\\])*?)(?=\\3)/g;\n// matches @import url(\"\"), @import url('a'), @import url(aa\\)a)\nconst importUrlRegex = /(@import)(\\s+url\\(\\s*)([\"']?)((?:\\\\.|[^\\\\])*?)(?=\\3\\s*\\))/g;\n// matches url(\"\"), url('a'), url(aa\\)aa) but not @import url('aa')\nconst urlRegex = /(?<!@import\\s+)(url)(\\(\\s*)([\"']?)((?:\\\\.|[^\\\\])*?)(?=\\3\\s*\\))/g;\n// unescapes backslashes. while this is fast and simple, it won't work with \\n, or unicode characters\nconst unescapeRegex = /\\\\(.)/g;\n// escapes ', \", or )\nconst escapeSingleQuote = /'/g;\nconst escapeDoubleQuote = /\"/g;\nconst escapeParentheses = /\\)/g;\nconst escapeBackslash = /\\\\/g;\nfunction unescapeString(str) {\n    return str.replace(unescapeRegex, '$1');\n}\nexports.unescapeString = unescapeString;\nfunction escapeString(str, delimiter) {\n    str = str.replace(escapeBackslash, '\\\\\\\\');\n    switch (delimiter) {\n        case \"'\":\n            return str.replace(escapeSingleQuote, \"\\\\'\");\n        case '\"':\n            return str.replace(escapeDoubleQuote, '\\\\\"');\n        case ')':\n            return str\n                .replace(escapeSingleQuote, \"\\\\'\")\n                .replace(escapeDoubleQuote, '\\\\\"')\n                .replace(escapeParentheses, '\\\\)');\n        default:\n            throw new TypeError('Unknown delimiter: ' + delimiter);\n    }\n}\nexports.escapeString = escapeString;\n/**\n *\n * @param cssText - string of the css contents\n * @param urlRewriteFunc - this function rewrites the url\n */\nfunction cssRewriter(cssText, urlRewriteFunc) {\n    function cssReplacer(_match, g1, g2, g3, g4) {\n        let delimiter = g3;\n        if (!g3) {\n            // delimiter must be ) if g3 is empty\n            delimiter = ')';\n        }\n        return g1 + g2 + g3 + escapeString(urlRewriteFunc(unescapeString(g4), g1), delimiter);\n    }\n    return cssText\n        .replace(importRegex, cssReplacer)\n        .replace(importUrlRegex, cssReplacer)\n        .replace(urlRegex, cssReplacer);\n}\nexports.cssRewriter = cssRewriter;\n\n\n//# sourceURL=webpack://PademelonWorker/./src/rewriters/css-rewriter.ts?");

/***/ }),

/***/ "./src/rewriters/js-rewriter.ts":
/*!**************************************!*\
  !*** ./src/rewriters/js-rewriter.ts ***!
  \**************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.invalidWindowPropRegex = exports.jsRewriter = void 0;\n/**\n * credits to https://stackoverflow.com/a/41704827/6850723\n * This method of using \"with\" has big advantages. You can:\n *   - Wrap code in a local scope and expose them appropriately without needing to parse it (note: not anymore, see below).\n *     So code like 'var bah = 0' in the global scope will be exposed correctly\n *   - Mutate immutable properties of window\n *   - Any reference to the window property can be intercepted, so 'location.href' can be intercepted\n *     even without the window part like: 'window.location.href'\n * Disadvantages:\n *   - it is ES6\n *   - it violates ES5 strict mode\n *   - function declarations are not exposed correctly, so wrapping in a local\n *     scope will be unfeasible. However, we can have an eval runner (or closure) that\n *     exposes its local scope and whenever another part of the website\n *     wants to access a global function variable, we can traverse through the\n *     chain of evals and add it to the window object if it exists\n *   - whenever we always return true in the 'has' trap, although it will expose\n *     global variables properly, it incorrectly outputs true for 'propdoesntexist' in modifiedWindow.\n *     However, we can use the eval expose variable method and it's a win win situation (rip heap memory though)\n *\n *\n * Sites that create a function and returning its \"this\" will expose the real\n * window object and immutable objects like window.location\n */\nconst invalidWindowPropRegex = /[^a-z_]/i;\nexports.invalidWindowPropRegex = invalidWindowPropRegex;\nconst signatureJSRewrite = '/* begin pademelon js rewrite */';\nfunction jsRewriter(jsCode, windowProp) {\n    if (invalidWindowPropRegex.test(windowProp)) {\n        throw new TypeError('Invalid windowProp ' + windowProp + '. Matches invalid regex ' + invalidWindowPropRegex);\n    }\n    if (!jsCode || jsCode.startsWith(signatureJSRewrite)) {\n        return jsCode;\n    }\n    const newline = /\\n|\\r/.test(jsCode) ? '\\n' : '';\n    return (signatureJSRewrite +\n        ' (function(){ var alreadyLookedupVars = Object.create(null); window.pademelonInstance.varLookupChain.push(function globalizeFunction(funcName) { ' +\n        'if (alreadyLookedupVars[funcName] !== undefined) return alreadyLookedupVars[funcName]; ' +\n        'try { eval(\"window.\" + funcName + \" = \" + funcName); alreadyLookedupVars[funcName] = true } catch(e) {alreadyLookedupVars[funcName] = false} ' +\n        'return alreadyLookedupVars[funcName]}); ' +\n        `with(window.${windowProp}.modifiedWindow) {${newline}${jsCode}${newline}}` +\n        `}).bind(this === window ? window.${windowProp}.modifiedWindow : this)()`);\n}\nexports.jsRewriter = jsRewriter;\n\n\n//# sourceURL=webpack://PademelonWorker/./src/rewriters/js-rewriter.ts?");

/***/ }),

/***/ "./src/rewriters/worker-js-rewriter.ts":
/*!*********************************************!*\
  !*** ./src/rewriters/worker-js-rewriter.ts ***!
  \*********************************************/
/***/ ((__unused_webpack_module, exports, __webpack_require__) => {

eval("\nObject.defineProperty(exports, \"__esModule\", ({ value: true }));\nexports.workerJsRewriter = void 0;\nconst js_rewriter_1 = __webpack_require__(/*! ./js-rewriter */ \"./src/rewriters/js-rewriter.ts\");\nconst signatureJSRewrite = '/* begin pademelon worker js rewrite */';\nfunction workerJsRewriter(workerJsCode, pademelonWorkerPath, pademelonWorkerOptions, selfProp) {\n    if (js_rewriter_1.invalidWindowPropRegex.test(selfProp)) {\n        throw new TypeError('Invalid selfProp ' + selfProp + '. Matches invalid regex ' + js_rewriter_1.invalidWindowPropRegex);\n    }\n    if (!workerJsCode || workerJsCode.startsWith(signatureJSRewrite)) {\n        return workerJsCode;\n    }\n    const newline = /\\n|\\r/.test(workerJsCode) ? '\\n' : ' ';\n    return (signatureJSRewrite +\n        `if (!self.${selfProp}) { importScripts('${pademelonWorkerPath}'); ` +\n        `self.${selfProp} = new PademelonWorker(${pademelonWorkerOptions}); self.${selfProp}.init(); }${newline}${workerJsCode}`);\n}\nexports.workerJsRewriter = workerJsRewriter;\n\n\n//# sourceURL=webpack://PademelonWorker/./src/rewriters/worker-js-rewriter.ts?");

/***/ }),

/***/ "./src/worker-browser-module.ts":
/*!**************************************!*\
  !*** ./src/worker-browser-module.ts ***!
  \**************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nconst base_rewriter_module_1 = __webpack_require__(/*! ./base-rewriter-module */ \"./src/base-rewriter-module.ts\");\nconst self_1 = __webpack_require__(/*! ./browser-rewrites/worker-rewrites/self */ \"./src/browser-rewrites/worker-rewrites/self/index.ts\");\nclass Pademelon extends base_rewriter_module_1.BasePademelon {\n    constructor(options) {\n        super(options);\n        this.workerRewriters = self_1.workerRewriters;\n        // since we are rewriting the location object directly (and it's read-only),\n        // we want to cache the original before rewriting\n        this.realLocation = new URL(self.location.href);\n    }\n    initWorkerRewrites() {\n        for (const eachRewriter of this.workerRewriters) {\n            eachRewriter(this);\n        }\n    }\n    init() {\n        this.initWorkerRewrites();\n    }\n    rewriteUrl(url, proxyPath = this.realLocation.pathname, mod) {\n        if (url === this.getBrowserPademelonDistUrl())\n            return url;\n        return super.rewriteUrl(url, proxyPath, mod);\n    }\n    unrewriteUrl(proxyUrl = this.realLocation.pathname) {\n        return super.unrewriteUrl(proxyUrl);\n    }\n}\nmodule.exports = Pademelon;\n\n\n//# sourceURL=webpack://PademelonWorker/./src/worker-browser-module.ts?");

/***/ })

/******/ 	});
/************************************************************************/
/******/ 	// The module cache
/******/ 	var __webpack_module_cache__ = {};
/******/ 	
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/ 		// Check if module is in cache
/******/ 		if(__webpack_module_cache__[moduleId]) {
/******/ 			return __webpack_module_cache__[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = __webpack_module_cache__[moduleId] = {
/******/ 			// no module.id needed
/******/ 			// no module.loaded needed
/******/ 			exports: {}
/******/ 		};
/******/ 	
/******/ 		// Execute the module function
/******/ 		__webpack_modules__[moduleId](module, module.exports, __webpack_require__);
/******/ 	
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/ 	
/************************************************************************/
/******/ 	
/******/ 	// startup
/******/ 	// Load entry module and return exports
/******/ 	// This entry module is referenced by other modules so it can't be inlined
/******/ 	var __webpack_exports__ = __webpack_require__("./src/worker-browser-module.ts");
/******/ 	PademelonWorker = __webpack_exports__;
/******/ 	
/******/ })()
;